
* App procedures: local and remote files
* CUDA
* Stack overflow avoidance?


* Multiple:
    * support lists of channels?

* register named input


Typing:
* Verify method to check that contents are of correct type?

Recursion
* Think about how to allow @func tasks to extend the DAG
    - Note: determined that function name resolves to wrapped 
        function in function body
    - Does it make sense to somehow logically "unpack" the result if
        there is a channel inside a channel
    - Need to get current thread to work on another task.

Programming Abstractions
* ResultBag, ResultList
* Parameter Sweep Primitives
    - combinations, permutations, etc combined with imap
* foldr, foldl, associative reduce (reduction tree), 
    associative commutative reduce (build reduction tree in order of completion)
* random number generations


Makefile:
* Implicit rules of Type -> Type
@ruleapp((OFile), (CFile), rename=('%.o', '%.c')) renamerexp?
* register files as sources or intermediates

sources = ["test.c", "test2.c"]
addsources(map(CFile.bind, sources))
 - intermediate files?

* need to be able to inspect file times and trace back to see if fresh
    .isFresh() method on channels that searches back through dependencies
    - need to determine if an channel with missing inputs is out of date or a 
    source: 

Streaming:
* resultbag() could be basis for a stream type

Work stealing + asynchronous evaluation:
* Split Deque data structure

Each thread:
   Stack frame for tasks which have some
   dependencies not started.  Each frame
   is just a tuple of unstarted tasks.
   -----------------
  |                 |
   -----------------                 
   
   Suspended deques which are waiting on
   result of asynchronous evaluation
         ----------------
        |               |  <- task running asynchronously
         ----------------
               ^
               | 
      Tasks which depend on that task

